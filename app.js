// DXF → toolpath → simple 2D verify sim (no stock removal)
// V1: LINE + (LW)POLYLINE straight segments only

const $ = (id) => document.getElementById(id);

const canvas = $("c");
const ctx = canvas.getContext("2d");

let dxfText = null;
let moves = [];        // {type:'rapid'|'cut'|'plunge'|'retract', x,y,z, feed?}
let segments = [];     // drawable segments from consecutive moves
let totalLen = 0;
let playing = false;
let lastDAT = "";

const state = {
  view: { scale: 1, ox: 0, oy: 0 }, // world->screen transform
  bounds: null, // {minX,maxX,minY,maxY}
};

function fmt(n) {
  const s = Number(n).toFixed(4);
  return s.replace(/\.?0+$/, "");
}

function resizeCanvas() {
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  canvas.width = Math.max(1, Math.floor(rect.width * dpr));
  canvas.height = Math.max(1, Math.floor(rect.height * dpr));
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  draw();
}

window.addEventListener("resize", resizeCanvas);

$("file").addEventListener("change", async (e) => {
  const file = e.target.files?.[0];
  if (!file) return;
  dxfText = await file.text();
  setStatus(`Loaded DXF: ${file.name}`);
});

$("build").addEventListener("click", () => {
  if (!dxfText) return alert("Choose a DXF first.");

  const opts = readOpts();

  let dxf;
  try {
    const parser = new window.DxfParser();
    dxf = parser.parseSync(dxfText);
  } catch (err) {
    console.error(err);
    return alert("DXF parse failed. Try exporting as R12 / ASCII DXF.");
  }

  const rawSegs = extractSegments(dxf);
  if (!rawSegs.length) return alert("No LINE or POLYLINE segments found.");

  moves = buildMovesFromSegments(rawSegs, opts);
  segments = buildDrawableSegments(moves);

  state.bounds = computeBoundsFromSegments(segments);
  fitToView(state.bounds);

  lastDAT = buildDAT(moves, opts);

  // UI enable
  $("download").disabled = false;
  $("play").disabled = false;
  $("pause").disabled = false;
  $("scrub").disabled = false;
  $("scrub").value = "0";
  playing = false;

  $("stats").textContent = `Moves: ${moves.length} | Length: ${fmt(totalLen)}`;
  setStatus("Built toolpath + sim ready.");
  draw();
});

$("download").addEventListener("click", () => {
  if (!lastDAT) return;
  downloadText(lastDAT, "output.dat");
});

$("play").addEventListener("click", () => { playing = true; });
$("pause").addEventListener("click", () => { playing = false; });

$("scrub").addEventListener("input", () => {
  playing = false;
  draw();
});

function readOpts() {
  return {
    units: $("units").value, // G20 / G21
    safeZ: Number($("safeZ").value),
    cutZ: Number($("cutZ").value),
    feedXY: Number($("feedXY").value),
    feedZ: Number($("feedZ").value),
    toolComment: $("toolComment").value || "(T1 - 1/4 endmill, no comp)"
  };
}

function setStatus(s) { $("status").textContent = `Status: ${s}`; }

// --- DXF parsing (V1 straight segments only) ---

function extractSegments(dxf) {
  const segs = [];
  for (const e of dxf.entities || []) {
    if (e.type === "LINE") {
      segs.push({ x1: e.start.x, y1: e.start.y, x2: e.end.x, y2: e.end.y });
    }
    if (e.type === "LWPOLYLINE" || e.type === "POLYLINE") {
      const verts = (e.vertices || []).map(v => ({ x: v.x, y: v.y, bulge: v.bulge || 0 }));
      if (verts.length < 2) continue;

      for (let i = 0; i < verts.length - 1; i++) {
        const a = verts[i], b = verts[i + 1];
        // Ignore bulge (arcs) in V1
        segs.push({ x1: a.x, y1: a.y, x2: b.x, y2: b.y });
      }
      if (e.closed) {
        const a = verts[verts.length - 1], b = verts[0];
        segs.push({ x1: a.x, y1: a.y, x2: b.x, y2: b.y });
      }
    }
  }
  return segs;
}

// --- Toolpath build (naive: each segment separately) ---

function buildMovesFromSegments(segs, opts) {
  const out = [];
  totalLen = 0;

  // header-ish moves not needed for sim, but helps state
  out.push({ type: "retract", x: 0, y: 0, z: opts.safeZ });

  for (const s of segs) {
    const len = Math.hypot(s.x2 - s.x1, s.y2 - s.y1);
    totalLen += len;

    out.push({ type: "rapid",  x: s.x1, y: s.y1, z: opts.safeZ });
    out.push({ type: "plunge", x: s.x1, y: s.y1, z: opts.cutZ, feed: opts.feedZ });
    out.push({ type: "cut",    x: s.x2, y: s.y2, z: opts.cutZ, feed: opts.feedXY });
    out.push({ type: "retract",x: s.x2, y: s.y2, z: opts.safeZ });
  }
  return out;
}

function buildDAT(moves, opts) {
  const g = [];
  g.push("%");
  g.push("(Generated by DXF→DAT V1)");
  g.push(opts.toolComment);
  g.push("G90 (absolute)");
  g.push("G94 (feed/min)");
  g.push(opts.units);
  g.push("G17 (XY plane)");
  g.push(`G0 Z${fmt(opts.safeZ)}`);

  let last = null;
  for (const m of moves) {
    if (m.type === "rapid") {
      g.push(`G0 X${fmt(m.x)} Y${fmt(m.y)}`);
    } else if (m.type === "plunge") {
      g.push(`G1 Z${fmt(m.z)} F${fmt(m.feed ?? opts.feedZ)}`);
    } else if (m.type === "cut") {
      g.push(`G1 X${fmt(m.x)} Y${fmt(m.y)} F${fmt(m.feed ?? opts.feedXY)}`);
    } else if (m.type === "retract") {
      g.push(`G0 Z${fmt(m.z)}`);
    }
    last = m;
  }

  g.push("M30");
  g.push("%");
  return g.join("\n");
}

function downloadText(text, filename) {
  const blob = new Blob([text], { type: "text/plain" });
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  a.click();
  URL.revokeObjectURL(a.href);
}

// --- SIM / DRAW ---

function fitToView(bounds) {
  if (!bounds) return;
  const pad = 20; // px
  const rect = canvas.getBoundingClientRect();
  const w = rect.width, h = rect.height;

  const bw = bounds.maxX - bounds.minX || 1;
  const bh = bounds.maxY - bounds.minY || 1;

  const sx = (w - pad * 2) / bw;
  const sy = (h - pad * 2) / bh;
  const scale = Math.min(sx, sy);

  state.view.scale = scale;
  // center
  const cx = (bounds.minX + bounds.maxX) / 2;
  const cy = (bounds.minY + bounds.maxY) / 2;

  state.view.ox = w / 2 - cx * scale;
  state.view.oy = h / 2 + cy * scale; // Y flips
}

function worldToScreen(x, y) {
  const s = state.view.scale;
  const ox = state.view.ox;
  const oy = state.view.oy;
  return { x: x * s + ox, y: -y * s + oy };
}

function computeBoundsFromSegments(segs) {
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  for (const s of segs) {
    minX = Math.min(minX, s.x1, s.x2);
    minY = Math.min(minY, s.y1, s.y2);
    maxX = Math.max(maxX, s.x1, s.x2);
    maxY = Math.max(maxY, s.y1, s.y2);
  }
  if (!isFinite(minX)) return null;
  return { minX, minY, maxX, maxY };
}

function buildDrawableSegments(moves) {
  const segs = [];
  let prev = null;
  for (const m of moves) {
    if (!prev) { prev = m; continue; }
    // draw only XY motion segments (rapid + cut)
    const xyMove = (m.type === "rapid" || m.type === "cut");
    if (xyMove && (prev.x !== undefined) && (m.x !== undefined)) {
      segs.push({
        x1: prev.x, y1: prev.y, z1: prev.z,
        x2: m.x, y2: m.y, z2: m.z,
        mode: m.type
      });
    }
    prev = m;
  }
  return segs;
}

function clear() {
  const rect = canvas.getBoundingClientRect();
  ctx.clearRect(0, 0, rect.width, rect.height);
}

function drawGrid() {
  const rect = canvas.getBoundingClientRect();
  const w = rect.width, h = rect.height;
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,0.05)";
  ctx.lineWidth = 1;

  const step = 50; // px
  for (let x = 0; x <= w; x += step) {
    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke();
  }
  for (let y = 0; y <= h; y += step) {
    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke();
  }
  ctx.restore();
}

function drawPath() {
  ctx.save();
  ctx.lineWidth = 2;

  // rapids first
  for (const s of segments) {
    if (s.mode !== "rapid") continue;
    const a = worldToScreen(s.x1, s.y1);
    const b = worldToScreen(s.x2, s.y2);
    ctx.strokeStyle = "rgba(120,170,255,0.65)";
    ctx.setLineDash([6, 6]);
    ctx.beginPath();
    ctx.moveTo(a.x, a.y);
    ctx.lineTo(b.x, b.y);
    ctx.stroke();
  }

  // cuts
  for (const s of segments) {
    if (s.mode !== "cut") continue;
    const a = worldToScreen(s.x1, s.y1);
    const b = worldToScreen(s.x2, s.y2);
    ctx.strokeStyle = "rgba(255,120,120,0.85)";
    ctx.setLineDash([]);
    ctx.beginPath();
    ctx.moveTo(a.x, a.y);
    ctx.lineTo(b.x, b.y);
    ctx.stroke();
  }

  ctx.restore();
}

function pointAtT(t01) {
  // Walk along drawable segments by distance (cuts + rapids) and find tool XY.
  if (!segments.length) return null;
  const lengths = [];
  let sum = 0;
  for (const s of segments) {
    const len = Math.hypot(s.x2 - s.x1, s.y2 - s.y1);
    lengths.push(len);
    sum += len;
  }
  const target = t01 * sum;

  let acc = 0;
  for (let i = 0; i < segments.length; i++) {
    const s = segments[i];
    const len = lengths[i];
    if (acc + len >= target) {
      const u = len === 0 ? 0 : (target - acc) / len;
      const x = s.x1 + (s.x2 - s.x1) * u;
      const y = s.y1 + (s.y2 - s.y1) * u;
      // Approximate Z state based on mode: rapid => safe, cut => cut
      const z = (s.mode === "cut") ? (s.z2 ?? 0) : (s.z2 ?? 0);
      return { x, y, z, mode: s.mode };
    }
    acc += len;
  }
  const last = segments[segments.length - 1];
  return { x: last.x2, y: last.y2, z: last.z2, mode: last.mode };
}

function drawTool(t01) {
  const p = pointAtT(t01);
  if (!p) return;

  const sp = worldToScreen(p.x, p.y);
  ctx.save();
  // tool dot
  ctx.fillStyle = p.mode === "cut" ? "rgba(255,120,120,0.95)" : "rgba(120,170,255,0.95)";
  ctx.beginPath();
  ctx.arc(sp.x, sp.y, 6, 0, Math.PI * 2);
  ctx.fill();

  // halo
  ctx.strokeStyle = "rgba(255,255,255,0.18)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(sp.x, sp.y, 14, 0, Math.PI * 2);
  ctx.stroke();
  ctx.restore();

  $("hudPos").textContent = `XYZ: ${fmt(p.x)} ${fmt(p.y)} ${p.z !== undefined ? fmt(p.z) : "—"}`;
  $("hudMode").textContent = `Mode: ${p.mode.toUpperCase()}`;
}

function draw() {
  clear();
  drawGrid();
  drawPath();

  const t = Number($("scrub").value);
  drawTool(t);
}

function tick() {
  if (playing) {
    const scrub = $("scrub");
    let v = Number(scrub.value);
    v += 0.003; // speed (UI speed, not feed-accurate)
    if (v >= 1) { v = 1; playing = false; }
    scrub.value = String(v);
    draw();
  }
  requestAnimationFrame(tick);
}

// boot
resizeCanvas();
tick();
